---
import Layout from '../layouts/Layout.astro';
import { SITE } from '../site';
---

<Layout title={`Pushup Counter — ${SITE.name}`} description="A phone-first pushup set counter with Sheets logging.">
	<h1>Pushup Counter</h1>

	<div class="card">
		<div id="locked">
			<p class="muted">
				Passcode required. This is meant to keep track of just my pushups.
			</p>
			<label class="label" for="passcode">Passcode</label>
			<input id="passcode" class="input" inputmode="numeric" autocomplete="one-time-code" />
			<div class="rowBtns authBtns">
				<button id="unlock" class="btn primary" type="button">Unlock</button>
				<button id="demo" class="btn" type="button">Try demo</button>
			</div>
			<p id="lockError" class="error" aria-live="polite"></p>
		</div>

		<div id="unlocked" hidden>
			<p id="demoNote" class="muted small" hidden>
				Demo mode. Counting works, but saving is disabled.
			</p>
			<div class="row">
				<div class="countWrap">
					<div class="countLabel muted">Set count</div>
					<div id="count" class="count">0</div>
				</div>
				<div class="rowBtns">
					<button id="inc" class="btn big primary" type="button">+1</button>
					<button id="dec" class="btn big" type="button">-1</button>
					<button id="reset" class="btn big" type="button">Reset</button>
				</div>
			</div>

			<div class="divider"></div>

			<div class="row">
				<div class="stack">
					<div class="muted">Style</div>
				</div>
				<fieldset class="segmented" aria-label="Pushup style">
					<label class="seg">
						<input type="radio" name="style" value="standard" checked />
						<span>Standard</span>
					</label>
					<label class="seg">
						<input type="radio" name="style" value="wide" />
						<span>Wide</span>
					</label>
					<label class="seg">
						<input type="radio" name="style" value="narrow" />
						<span>Narrow</span>
					</label>
				</fieldset>
			</div>

			<div class="divider"></div>

			<div class="row">
				<div class="stack">
					<div class="muted">Logging</div>
					<div id="logHelp" class="muted small">
						Adds one row to your Google Sheet when you finish a set.
					</div>
				</div>
				<button id="save" class="btn primary" type="button">Finish set &amp; save</button>
			</div>

			<p id="status" class="muted small" aria-live="polite"></p>

			<details class="details">
				<summary>Proximity counting (experimental)</summary>
				<p class="muted small">
					If your browser supports it, you can use the camera to count reps hands-free. Tap counter
					is still the reliable mode.
				</p>
				<p class="muted small">
					For your “phone on the ground, screen up” flow, use <strong>Proximity (camera)</strong> and
					calibrate the threshold so it flips state when your face gets close.
				</p>

				<div class="divider"></div>
				<p class="muted small"><strong>Proximity (camera)</strong></p>
				<div class="row">
					<fieldset class="segmented" aria-label="Proximity mode">
						<label class="seg">
							<input type="radio" name="proxMode" value="enabled" />
							<span>Enable</span>
						</label>
						<label class="seg">
							<input type="radio" name="proxMode" value="disabled" checked />
							<span>Disable</span>
						</label>
					</fieldset>
					<label class="label inline" for="proxThreshold">Threshold</label>
					<div class="range">
						<span class="rangeIcon" aria-hidden="true">◼︎</span>
						<input id="proxThreshold" type="range" min="0" max="255" step="1" value="95" />
						<span class="rangeIcon" aria-hidden="true">☀︎</span>
					</div>
					<label class="label inline checkbox">
						<input id="proxInvert" type="checkbox" />
						Invert
					</label>
				</div>
				<div class="row">
					<div class="muted small">Live signal</div>
					<div id="proxSignal" class="mono small muted">—</div>
				</div>

				<div class="divider"></div>
				<p class="muted small"><strong>Calibration</strong></p>
				<div class="row">
					<div class="rowBtns">
						<button id="calAway" class="btn" type="button">Set away</button>
						<button id="calClose" class="btn" type="button">Set close</button>
						<button id="calReset" class="btn" type="button">Reset</button>
					</div>
					<div id="calStatus" class="muted small">Not calibrated</div>
				</div>
			</details>

			<div class="divider"></div>

			<button id="lock" class="btn" type="button">Lock</button>
		</div>
	</div>
</Layout>

<style>
	.card {
		border: 1px solid var(--border);
		border-radius: 14px;
		padding: 1rem;
		margin: 1rem 0 2rem;
	}

	.row {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 0.75rem;
		flex-wrap: wrap;
	}

	.segmented {
		display: inline-flex;
		border: 1px solid var(--border);
		border-radius: 12px;
		overflow: hidden;
		margin: 0;
		padding: 0;
	}

	.seg {
		display: inline-flex;
		font-size: 15px;
		cursor: pointer;
		user-select: none;
		border-right: 1px solid var(--border);
	}

	.seg:last-child {
		border-right: none;
	}

	.seg input {
		position: absolute;
		opacity: 0;
		pointer-events: none;
	}

	.seg span {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		padding: 0.55rem 0.75rem;
		background: white;
		color: var(--muted);
	}

	.seg input:checked + span {
		background: #111827;
		color: white;
		border-right-color: #111827;
	}

	.stack {
		display: grid;
		gap: 0.25rem;
	}

	.countWrap {
		min-width: 140px;
	}

	.countLabel {
		font-size: 0.95rem;
		margin-bottom: 0.25rem;
	}

	.count {
		font-size: 64px;
		line-height: 1;
		letter-spacing: -0.03em;
		font-weight: 650;
	}

	.rowBtns {
		display: flex;
		gap: 0.5rem;
		align-items: center;
		flex-wrap: wrap;
	}

	.authBtns {
		margin-top: 0.75rem;
	}

	.divider {
		border-top: 1px solid var(--border);
		margin: 1rem 0;
	}

	.label {
		display: block;
		margin: 0.75rem 0 0.25rem;
		color: var(--muted);
		font-size: 0.95rem;
	}

	.label.inline {
		margin: 0;
	}

	.checkbox {
		display: inline-flex;
		align-items: center;
		gap: 0.4rem;
	}

	.checkbox input {
		margin: 0;
	}

	.range {
		display: inline-flex;
		align-items: center;
		gap: 0.5rem;
		flex: 1;
		min-width: 0;
	}

	.range input[type='range'] {
		flex: 1;
		min-width: 0;
	}

	.rangeIcon {
		color: var(--muted);
		font-size: 14px;
		line-height: 1;
		user-select: none;
	}

	.input {
		width: 100%;
		max-width: 320px;
		padding: 0.7rem 0.75rem;
		border-radius: 10px;
		border: 1px solid var(--border);
		font-size: 16px;
	}

	.btn {
		border: 1px solid var(--border);
		background: white;
		border-radius: 12px;
		padding: 0.6rem 0.85rem;
		font-size: 16px;
		cursor: pointer;
	}

	.btn.primary {
		background: #111827;
		color: white;
		border-color: #111827;
	}

	.btn.big {
		padding: 0.9rem 1.1rem;
		font-size: 18px;
	}

	.btn:active {
		transform: translateY(1px);
	}

	.btn:disabled {
		opacity: 0.55;
		cursor: not-allowed;
	}

	.btn:disabled:active {
		transform: none;
	}

	.small {
		font-size: 0.95rem;
	}

	.mono {
		font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New',
			monospace;
	}

	.details {
		margin-top: 0.75rem;
	}

	.error {
		color: #b91c1c;
		margin-top: 0.5rem;
	}

	@media (max-width: 640px) {
		.count {
			font-size: 72px;
		}

		.btn.big {
			flex: 1;
			min-width: 120px;
		}
	}
</style>

<script>
	// @ts-nocheck
	const WEBHOOK_URL = import.meta.env.PUBLIC_PUSHUP_WEBHOOK_URL || '';
	const API_URL = '/api/pushups';
	const EXPECTED_PASSCODE = import.meta.env.PUBLIC_PUSHUP_PASSCODE || '1021';
	const AUTH_URL = '/api/auth';

	const STORAGE_KEY = 'pushupCounterUnlocked';
	const STYLE_KEY = 'pushupCounterStyle';

	const el = {
		locked: document.getElementById('locked'),
		unlocked: document.getElementById('unlocked'),
		passcode: document.getElementById('passcode'),
		unlock: document.getElementById('unlock'),
		demo: document.getElementById('demo'),
		lock: document.getElementById('lock'),
		lockError: document.getElementById('lockError'),
		demoNote: document.getElementById('demoNote'),
		count: document.getElementById('count'),
		inc: document.getElementById('inc'),
		dec: document.getElementById('dec'),
		reset: document.getElementById('reset'),
		save: document.getElementById('save'),
		status: document.getElementById('status'),
		proxThreshold: document.getElementById('proxThreshold'),
		proxInvert: document.getElementById('proxInvert'),
		proxSignal: document.getElementById('proxSignal'),
		calAway: document.getElementById('calAway'),
		calClose: document.getElementById('calClose'),
		calReset: document.getElementById('calReset'),
		calStatus: document.getElementById('calStatus'),
	};

	function setStatus(text) {
		el.status.textContent = text;
	}

	function setError(text) {
		el.lockError.textContent = text;
	}

	function isUnlocked() {
		return localStorage.getItem(STORAGE_KEY) === '1';
	}

	function getPasscode() {
		return String(el.passcode.value || '').trim();
	}

	function getStyle() {
		return String(document.querySelector('input[name="style"]:checked')?.value || 'standard');
	}

	function setStyle(value) {
		const radio = document.querySelector(`input[name="style"][value="${value}"]`);
		if (radio) radio.checked = true;
	}

	function showUnlocked() {
		el.locked.hidden = true;
		el.unlocked.hidden = false;
	}

	function showLocked() {
		el.unlocked.hidden = true;
		el.locked.hidden = false;
		el.passcode.value = '';
	}

	let demoMode = false;
	function setDemoMode(next) {
		demoMode = Boolean(next);
		el.demoNote.hidden = !demoMode;
		el.save.disabled = demoMode;
	}

	function lock() {
		disableProximity({ quiet: true });
		setDemoMode(false);
		localStorage.removeItem(STORAGE_KEY);
		el.passcode.value = '';
		showLocked();
		setError('');
		setStatus('');
	}

	function unlock() {
		const entered = getPasscode();

		setError('');
		setStatus('');

		(async () => {
			// In production we authenticate with an HttpOnly cookie set by /api/auth.
			if (!import.meta.env.DEV) {
				try {
					const res = await fetch(AUTH_URL, {
						method: 'POST',
						headers: { 'content-type': 'application/json' },
						body: JSON.stringify({ passcode: entered }),
					});
					const data = await res.json().catch(() => ({}));
					if (!res.ok || !data.ok) throw new Error(data.error || `HTTP_${res.status}`);
				} catch (err) {
					setError('Incorrect passcode.');
					return;
				}
			} else {
				// Local dev: basic client-side gate only.
				if (entered !== EXPECTED_PASSCODE) {
					setError('Incorrect passcode.');
					return;
				}
			}

			setDemoMode(false);
			localStorage.setItem(STORAGE_KEY, '1');
			el.passcode.value = '';
			showUnlocked();
			setError('');
		})();
	}

	function enterDemo() {
		setDemoMode(true);
		showUnlocked();
		setError('');
		setStatus('Demo mode. Saving is disabled.');
	}

	let count = 0;
	function renderCount() {
		el.count.textContent = String(count);
	}

	function sendGetBeacon(url) {
		return new Promise((resolve) => {
			const img = new Image();
			const done = () => resolve(null);
			const timeout = setTimeout(done, 2500);
			img.onload = () => {
				clearTimeout(timeout);
				done();
			};
			img.onerror = () => {
				clearTimeout(timeout);
				done();
			};
			img.src = url;
		});
	}

	async function saveSet() {
		if (demoMode) {
			setStatus('Demo mode. Saving is disabled.');
			return;
		}

		if (count <= 0) {
			setStatus('Nothing to save yet.');
			return;
		}

		if (!isUnlocked()) {
			setStatus('Unlock to enable saving.');
			return;
		}

		const now = new Date();
		const recordedAt = now.toISOString();
		const recordedDate = new Intl.DateTimeFormat('en-US', {
			month: 'short',
			day: '2-digit',
			year: 'numeric',
		}).format(now);
		const recordedTime = new Intl.DateTimeFormat('en-US', {
			hour: 'numeric',
			minute: '2-digit',
		}).format(now);

		setStatus('Saving…');
		try {
			const payload = {
				date: recordedDate,
				time: recordedTime,
				count,
				style: getStyle(),
				recordedAt,
			};

			if (import.meta.env.DEV) {
				if (!WEBHOOK_URL) {
					setStatus('No webhook configured.');
					return;
				}
				const url = new URL(WEBHOOK_URL);
				Object.entries(payload).forEach(([k, v]) => url.searchParams.set(k, String(v)));
				url.searchParams.set('v', String(Date.now()));
				await sendGetBeacon(url.toString());
			} else {
				const res = await fetch(API_URL, {
					method: 'POST',
					headers: { 'content-type': 'application/json' },
					body: JSON.stringify(payload),
				});
				const data = await res.json().catch(() => ({}));
				if (!res.ok || !data.ok) {
					throw new Error(
						typeof data.error === 'string' ? data.error : `HTTP_${res.status}`,
					);
				}
			}

			setStatus('Saved. Resetting set.');
			count = 0;
			renderCount();
		} catch (err) {
			setStatus(`Save failed. (${String(err)})`);
		}
	}

	// Proximity (camera) counting: counts on far -> near transitions.
	let proxEnabled = false;
	let proxNear = false;
	let proxLastRepAt = 0;
	let proxLastLuma = null;
	let calAway = null;
	let calClose = null;
	let proxStream = null;
	let proxVideo = null;
	let proxCanvas = null;
	let proxCtx = null;
	let proxRaf = 0;

	function setProxMode(mode) {
		const radio = document.querySelector(`input[name="proxMode"][value="${mode}"]`);
		if (radio) radio.checked = true;
	}

	function proxThreshold() {
		return Number(el.proxThreshold.value || '95');
	}

	function proxIsInverted() {
		return Boolean(el.proxInvert.checked);
	}

	function proxSignalText(value, near) {
		return `${Math.round(value)}${near ? ' (near)' : ' (far)'}`;
	}

	function setCalStatus(text) {
		el.calStatus.textContent = text;
	}

	function resetCalibration() {
		calAway = null;
		calClose = null;
		setCalStatus('Not calibrated');
	}

	function updateCalibrationStatus() {
		if (calAway == null && calClose == null) {
			setCalStatus('Not calibrated');
			return;
		}
		if (calAway != null && calClose == null) {
			setCalStatus(`Away set: ${Math.round(calAway)}. Set close next.`);
			return;
		}
		if (calAway == null && calClose != null) {
			setCalStatus(`Close set: ${Math.round(calClose)}. Set away next.`);
			return;
		}
		const mid = (calAway + calClose) / 2;
		setCalStatus(`Calibrated. Away ${Math.round(calAway)} / Close ${Math.round(calClose)}.`);
		// Auto-place the slider at the midpoint for fine-tuning.
		el.proxThreshold.value = String(Math.round(mid));
	}

	function setAwayFromLive() {
		if (proxLastLuma == null) return;
		calAway = proxLastLuma;
		updateCalibrationStatus();
	}

	function setCloseFromLive() {
		if (proxLastLuma == null) return;
		calClose = proxLastLuma;
		updateCalibrationStatus();
	}

	function proxUpdateLoop() {
		if (!proxEnabled) return;
		if (!proxVideo || proxVideo.readyState < 2) {
			proxRaf = requestAnimationFrame(proxUpdateLoop);
			return;
		}

		const vw = proxVideo.videoWidth || 0;
		const vh = proxVideo.videoHeight || 0;
		if (!vw || !vh) {
			proxRaf = requestAnimationFrame(proxUpdateLoop);
			return;
		}

		// Center crop, downsample.
		const size = 64;
		const sx = Math.max(0, Math.floor(vw / 2 - size));
		const sy = Math.max(0, Math.floor(vh / 2 - size));
		const sw = Math.min(vw, size * 2);
		const sh = Math.min(vh, size * 2);

		proxCtx.drawImage(proxVideo, sx, sy, sw, sh, 0, 0, size, size);
		const data = proxCtx.getImageData(0, 0, size, size).data;

		// Average luma (0..255)
		let sum = 0;
		for (let i = 0; i < data.length; i += 4) {
			sum += 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];
		}
		const luma = sum / (data.length / 4);
		proxLastLuma = luma;

		const thr = proxThreshold();
		const margin = 10; // hysteresis
		const inverted = proxIsInverted();

		// Require calibration to count; still display signal.
		const calibrated = calAway != null && calClose != null;
		const closeIsDarker = calibrated ? calClose < calAway : true;

		const nearNow = !calibrated
			? false
			: inverted
				? closeIsDarker
					? luma > thr
					: luma < thr
				: closeIsDarker
					? luma < thr
					: luma > thr;

		const farNow = !calibrated
			? true
			: inverted
				? closeIsDarker
					? luma < thr - margin
					: luma > thr + margin
				: closeIsDarker
					? luma > thr + margin
					: luma < thr - margin;

		if (!proxNear && nearNow) {
			const now = Date.now();
			if (now - proxLastRepAt > 850) {
				proxLastRepAt = now;
				count += 1;
				renderCount();
			}
			proxNear = true;
		} else if (proxNear && farNow) {
			proxNear = false;
		}

		el.proxSignal.textContent = proxSignalText(luma, proxNear);
		proxRaf = requestAnimationFrame(proxUpdateLoop);
	}

	async function enableProximity() {
		if (proxEnabled) return;
		if (!navigator.mediaDevices?.getUserMedia) {
			setStatus('Camera not supported in this browser.');
			return;
		}

		try {
			proxStream = await navigator.mediaDevices.getUserMedia({
				video: { facingMode: 'user' },
				audio: false,
			});
		} catch {
			setStatus('Camera permission denied.');
			setProxMode('disabled');
			return;
		}

		proxVideo = document.createElement('video');
		proxVideo.playsInline = true;
		proxVideo.muted = true;
		proxVideo.srcObject = proxStream;
		await proxVideo.play().catch(() => {});

		proxCanvas = document.createElement('canvas');
		proxCanvas.width = 64;
		proxCanvas.height = 64;
		proxCtx = proxCanvas.getContext('2d', { willReadFrequently: true });
		if (!proxCtx) {
			setStatus('Camera processing not available.');
			disableProximity({ quiet: true });
			return;
		}

		proxEnabled = true;
		proxNear = false;
		proxLastRepAt = 0;
		proxLastLuma = null;
		resetCalibration();
		el.proxSignal.textContent = '…';
		setProxMode('enabled');
		setStatus('Proximity enabled. Calibrate away + close.');
		proxUpdateLoop();
	}

	function disableProximity({ quiet } = { quiet: false }) {
		if (!proxEnabled && !proxStream) return;
		proxEnabled = false;
		proxNear = false;
		proxLastRepAt = 0;
		proxLastLuma = null;
		resetCalibration();
		if (proxRaf) cancelAnimationFrame(proxRaf);
		proxRaf = 0;

		if (proxStream) {
			for (const t of proxStream.getTracks()) t.stop();
		}
		proxStream = null;
		proxVideo = null;
		proxCanvas = null;
		proxCtx = null;
		el.proxSignal.textContent = '—';
		setProxMode('disabled');
		if (!quiet) setStatus('Proximity disabled.');
	}

	// Wire up UI
	el.inc.addEventListener('click', () => {
		count += 1;
		renderCount();
	});
	el.dec.addEventListener('click', () => {
		count = Math.max(0, count - 1);
		renderCount();
	});
	el.reset.addEventListener('click', () => {
		count = 0;
		renderCount();
		setStatus('');
	});
	el.unlock.addEventListener('click', unlock);
	el.demo.addEventListener('click', enterDemo);
	el.lock.addEventListener('click', lock);
	el.save.addEventListener('click', saveSet);
	document.querySelectorAll('input[name="proxMode"]').forEach((radio) => {
		radio.addEventListener('change', () => {
			const mode = String(document.querySelector('input[name="proxMode"]:checked')?.value || 'disabled');
			if (mode === 'enabled') enableProximity();
			else disableProximity();
		});
	});
	el.calAway.addEventListener('click', setAwayFromLive);
	el.calClose.addEventListener('click', setCloseFromLive);
	el.calReset.addEventListener('click', resetCalibration);
	el.passcode.addEventListener('keydown', (e) => {
		if (e.key === 'Enter') unlock();
	});
	document.querySelectorAll('input[name="style"]').forEach((radio) => {
		radio.addEventListener('change', () => localStorage.setItem(STYLE_KEY, getStyle()));
	});

	// Initial state
	el.passcode.value = '';
	setStyle(localStorage.getItem(STYLE_KEY) || 'standard');
	setProxMode('disabled');
	setDemoMode(false);
	if (isUnlocked()) showUnlocked();
</script>

